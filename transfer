import os
import argparse
from pathlib import Path
from typing import List, Set
import mimetypes

class ProjectAnalyzer:
    def __init__(self, root_path: str, output_file: str = "project_analysis.txt"):
        self.root_path = Path(root_path).resolve()
        self.output_file = output_file
        
        # Common code file extensions
        self.code_extensions = {
            '.py', '.js', '.jsx', '.ts', '.tsx', '.java', '.cpp', '.c', '.h', 
            '.cs', '.php', '.rb', '.go', '.rs', '.swift', '.kt', '.scala',
            '.html', '.css', '.scss', '.sass', '.sql', '.sh', '.bash',
            '.yaml', '.yml', '.json', '.xml', '.toml', '.ini', '.cfg',
            '.md', '.rst', '.txt', '.dockerfile', '.env', '.gitignore',
            '.ipynb'  # Jupyter notebooks
        }
        
        # Directories to skip
        self.skip_dirs = {
            '__pycache__', '.git', '.svn', '.hg', 'node_modules', 
            '.pytest_cache', '.mypy_cache', '.tox', 'venv', 'env',
            '.env', '.venv', 'dist', 'build', '.idea', '.vscode',
            'coverage', '.coverage', 'htmlcov', '.DS_Store',
            '*.egg-info', '.eggs', 'wheels', '.sass-cache'
        }
        
        # Files to skip
        self.skip_files = {
            '.DS_Store', 'Thumbs.db', '*.pyc', '*.pyo', '*.pyd',
            '*.so', '*.dylib', '*.dll', '*.class', '*.exe'
        }
        
        # Maximum file size (in KB) to include
        self.max_file_size = 500  # 500KB
        
    def should_skip_dir(self, dir_path: Path) -> bool:
        """Check if directory should be skipped"""
        dir_name = dir_path.name
        return any(
            dir_name == skip or 
            dir_name.startswith('.') and dir_name != '.' or
            skip in str(dir_path)
            for skip in self.skip_dirs
        )
    
    def should_skip_file(self, file_path: Path) -> bool:
        """Check if file should be skipped"""
        file_name = file_path.name
        
        # Skip if file matches skip patterns
        if any(skip in file_name for skip in self.skip_files):
            return True
            
        # Skip if file is too large
        try:
            if file_path.stat().st_size > self.max_file_size * 1024:
                return True
        except:
            return True
            
        # Skip binary files
        try:
            mime_type, _ = mimetypes.guess_type(str(file_path))
            if mime_type and mime_type.startswith(('image/', 'video/', 'audio/', 'application/octet-stream')):
                return True
        except:
            pass
            
        return False
    
    def is_code_file(self, file_path: Path) -> bool:
        """Check if file is a code file based on extension"""
        # Check common code extensions
        if file_path.suffix.lower() in self.code_extensions:
            return True
            
        # Check files without extensions (like Dockerfile, Makefile)
        if file_path.name in ['Dockerfile', 'Makefile', 'Rakefile', 'Gemfile', 'Pipfile']:
            return True
            
        return False
    
    def generate_tree_structure(self, path: Path, prefix: str = "", is_last: bool = True) -> List[str]:
        """Generate tree structure similar to 'tree' command"""
        lines = []
        
        if path == self.root_path:
            lines.append(f"üìÅ {path.name}/")
        else:
            connector = "‚îî‚îÄ‚îÄ " if is_last else "‚îú‚îÄ‚îÄ "
            if path.is_dir():
                lines.append(f"{prefix}{connector}üìÅ {path.name}/")
            else:
                icon = "üìÑ" if self.is_code_file(path) else "üìã"
                lines.append(f"{prefix}{connector}{icon} {path.name}")
        
        if path.is_dir() and not self.should_skip_dir(path):
            try:
                items = sorted(list(path.iterdir()), key=lambda x: (not x.is_dir(), x.name.lower()))
                
                for i, item in enumerate(items):
                    if item.is_dir() and self.should_skip_dir(item):
                        continue
                    if item.is_file() and self.should_skip_file(item):
                        continue
                        
                    is_last_item = i == len(items) - 1
                    extension = "    " if is_last else "‚îÇ   "
                    
                    if path == self.root_path:
                        lines.extend(self.generate_tree_structure(item, "", is_last_item))
                    else:
                        lines.extend(self.generate_tree_structure(item, prefix + extension, is_last_item))
            except PermissionError:
                pass
                
        return lines
    
    def read_file_content(self, file_path: Path) -> str:
        """Read file content with error handling"""
        try:
            # Try reading as text
            with open(file_path, 'r', encoding='utf-8') as f:
                return f.read()
        except UnicodeDecodeError:
            try:
                # Try with latin-1 encoding
                with open(file_path, 'r', encoding='latin-1') as f:
                    return f.read()
            except:
                return f"[Error: Unable to read file - possibly binary or encoding issue]"
        except Exception as e:
            return f"[Error reading file: {str(e)}]"
    
    def analyze_project(self, include_all_files: bool = False):
        """Main method to analyze the project"""
        output_lines = []
        
        # Header
        output_lines.append("=" * 80)
        output_lines.append(f"PROJECT ANALYSIS: {self.root_path.name}")
        output_lines.append("=" * 80)
        output_lines.append("")
        
        # Project structure
        output_lines.append("## PROJECT STRUCTURE")
        output_lines.append("-" * 40)
        tree_lines = self.generate_tree_structure(self.root_path)
        output_lines.extend(tree_lines)
        output_lines.append("")
        
        # File contents
        output_lines.append("## FILE CONTENTS")
        output_lines.append("-" * 40)
        
        file_count = 0
        total_lines = 0
        
        for root, dirs, files in os.walk(self.root_path):
            root_path = Path(root)
            
            # Skip directories
            dirs[:] = [d for d in dirs if not self.should_skip_dir(root_path / d)]
            
            for file in sorted(files):
                file_path = root_path / file
                
                if self.should_skip_file(file_path):
                    continue
                    
                if not include_all_files and not self.is_code_file(file_path):
                    continue
                
                relative_path = file_path.relative_to(self.root_path)
                
                output_lines.append("")
                output_lines.append("=" * 60)
                output_lines.append(f"FILE: {relative_path}")
                output_lines.append("=" * 60)
                
                content = self.read_file_content(file_path)
                output_lines.append(content)
                
                file_count += 1
                total_lines += len(content.splitlines())
                
                # Add separator
                output_lines.append("")
                output_lines.append("~" * 60)
        
        # Summary statistics
        output_lines.append("")
        output_lines.append("=" * 80)
        output_lines.append("## SUMMARY")
        output_lines.append("-" * 40)
        output_lines.append(f"Total files analyzed: {file_count}")
        output_lines.append(f"Total lines of code: {total_lines}")
        output_lines.append(f"Output saved to: {self.output_file}")
        output_lines.append("=" * 80)
        
        # Write to file
        with open(self.output_file, 'w', encoding='utf-8') as f:
            f.write('\n'.join(output_lines))
        
        # Also print summary to console
        print(f"\n‚úÖ Project analysis complete!")
        print(f"üìÑ Files analyzed: {file_count}")
        print(f"üìù Total lines: {total_lines}")
        print(f"üíæ Output saved to: {self.output_file}")
        print(f"\nüìã You can now copy the contents of '{self.output_file}' to your AI chatbox.")
        
        # Check if output is very large
        output_size = os.path.getsize(self.output_file) / 1024  # Size in KB
        if output_size > 100:
            print(f"\n‚ö†Ô∏è  Warning: Output file is {output_size:.1f}KB. You may need to split it into chunks for the chatbox.")
            self.create_chunked_files(output_lines)
    
    def create_chunked_files(self, lines: List[str], chunk_size: int = 5000):
        """Create chunked files if output is too large"""
        print("\nüìÇ Creating chunked files...")
        
        chunks = []
        current_chunk = []
        current_size = 0
        
        for line in lines:
            current_chunk.append(line)
            current_size += 1
            
            if current_size >= chunk_size:
                chunks.append(current_chunk)
                current_chunk = []
                current_size = 0
        
        if current_chunk:
            chunks.append(current_chunk)
        
        # Write chunks
        base_name = self.output_file.replace('.txt', '')
        for i, chunk in enumerate(chunks, 1):
            chunk_file = f"{base_name}_part{i}.txt"
            with open(chunk_file, 'w', encoding='utf-8') as f:
                f.write('\n'.join(chunk))
            print(f"  ‚úÖ Created: {chunk_file}")

def main():
    parser = argparse.ArgumentParser(
        description="Extract project code and structure for AI analysis"
    )
    parser.add_argument(
        "path", 
        nargs="?", 
        default=".", 
        help="Path to project directory (default: current directory)"
    )
    parser.add_argument(
        "-o", "--output",
        default="project_analysis.txt",
        help="Output file name (default: project_analysis.txt)"
    )
    parser.add_argument(
        "-a", "--all",
        action="store_true",
        help="Include all text files, not just code files"
    )
    parser.add_argument(
        "--max-size",
        type=int,
        default=500,
        help="Maximum file size in KB to include (default: 500)"
    )
    
    args = parser.parse_args()
    
    # Create analyzer
    analyzer = ProjectAnalyzer(args.path, args.output)
    analyzer.max_file_size = args.max_size
    
    # Run analysis
    print(f"üîç Analyzing project: {os.path.abspath(args.path)}")
    analyzer.analyze_project(include_all_files=args.all)

if __name__ == "__main__":
    main()
